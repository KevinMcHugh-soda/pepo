// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: themes.sql

package db

import (
	"context"
)

const createTheme = `-- name: CreateTheme :one
INSERT INTO theme (id, person_id, text)
VALUES (x2b($1), x2b($2), $3)
RETURNING theme.id, theme.person_id, theme.text, theme.created_at, theme.updated_at
`

type CreateThemeParams struct {
	ID       string `db:"id" json:"id"`
	PersonID string `db:"person_id" json:"person_id"`
	Text     string `db:"text" json:"text"`
}

type CreateThemeRow struct {
	Theme Theme `db:"theme" json:"theme"`
}

func (q *Queries) CreateTheme(ctx context.Context, arg CreateThemeParams) (CreateThemeRow, error) {
	row := q.db.QueryRowContext(ctx, createTheme, arg.ID, arg.PersonID, arg.Text)
	var i CreateThemeRow
	err := row.Scan(
		&i.Theme.ID,
		&i.Theme.PersonID,
		&i.Theme.Text,
		&i.Theme.CreatedAt,
		&i.Theme.UpdatedAt,
	)
	return i, err
}

const deleteTheme = `-- name: DeleteTheme :exec
DELETE FROM theme
WHERE id = x2b($1)
`

func (q *Queries) DeleteTheme(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTheme, id)
	return err
}

const getThemeByID = `-- name: GetThemeByID :one
SELECT theme.id, theme.person_id, theme.text, theme.created_at, theme.updated_at
FROM theme
WHERE id = x2b($1)
`

type GetThemeByIDRow struct {
	Theme Theme `db:"theme" json:"theme"`
}

func (q *Queries) GetThemeByID(ctx context.Context, id string) (GetThemeByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getThemeByID, id)
	var i GetThemeByIDRow
	err := row.Scan(
		&i.Theme.ID,
		&i.Theme.PersonID,
		&i.Theme.Text,
		&i.Theme.CreatedAt,
		&i.Theme.UpdatedAt,
	)
	return i, err
}

const listThemes = `-- name: ListThemes :many
SELECT theme.id, theme.person_id, theme.text, theme.created_at, theme.updated_at
FROM theme
ORDER BY created_at DESC
LIMIT $2 OFFSET $1
`

type ListThemesParams struct {
	Offset int32 `db:"offset" json:"offset"`
	Limit  int32 `db:"limit" json:"limit"`
}

type ListThemesRow struct {
	Theme Theme `db:"theme" json:"theme"`
}

func (q *Queries) ListThemes(ctx context.Context, arg ListThemesParams) ([]ListThemesRow, error) {
	rows, err := q.db.QueryContext(ctx, listThemes, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListThemesRow{}
	for rows.Next() {
		var i ListThemesRow
		if err := rows.Scan(
			&i.Theme.ID,
			&i.Theme.PersonID,
			&i.Theme.Text,
			&i.Theme.CreatedAt,
			&i.Theme.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listThemesByPersonID = `-- name: ListThemesByPersonID :many
SELECT theme.id, theme.person_id, theme.text, theme.created_at, theme.updated_at
FROM theme
WHERE person_id = x2b($1)
ORDER BY created_at DESC
LIMIT $3 OFFSET $2
`

type ListThemesByPersonIDParams struct {
	PersonID string `db:"person_id" json:"person_id"`
	Offset   int32  `db:"offset" json:"offset"`
	Limit    int32  `db:"limit" json:"limit"`
}

type ListThemesByPersonIDRow struct {
	Theme Theme `db:"theme" json:"theme"`
}

func (q *Queries) ListThemesByPersonID(ctx context.Context, arg ListThemesByPersonIDParams) ([]ListThemesByPersonIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listThemesByPersonID, arg.PersonID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListThemesByPersonIDRow{}
	for rows.Next() {
		var i ListThemesByPersonIDRow
		if err := rows.Scan(
			&i.Theme.ID,
			&i.Theme.PersonID,
			&i.Theme.Text,
			&i.Theme.CreatedAt,
			&i.Theme.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
