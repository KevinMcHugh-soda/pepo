// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: persons.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const countPersons = `-- name: CountPersons :one
SELECT COUNT(*) FROM person
`

func (q *Queries) CountPersons(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPersons)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPerson = `-- name: CreatePerson :one
INSERT INTO person (id, name)
VALUES (x2b($1), $2)
RETURNING b2x(id) as id, name, created_at, updated_at
`

type CreatePersonParams struct {
	ID   string `db:"id" json:"id"`
	Name string `db:"name" json:"name"`
}

type CreatePersonRow struct {
	ID        string    `db:"id" json:"id"`
	Name      string    `db:"name" json:"name"`
	CreatedAt time.Time `db:"created_at" json:"created_at"`
	UpdatedAt time.Time `db:"updated_at" json:"updated_at"`
}

func (q *Queries) CreatePerson(ctx context.Context, arg CreatePersonParams) (CreatePersonRow, error) {
	row := q.db.QueryRowContext(ctx, createPerson, arg.ID, arg.Name)
	var i CreatePersonRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePerson = `-- name: DeletePerson :exec
DELETE FROM person
WHERE id = x2b($1)
`

func (q *Queries) DeletePerson(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deletePerson, id)
	return err
}

const getPersonByID = `-- name: GetPersonByID :one
SELECT b2x(id) as id, name, created_at, updated_at
FROM person
WHERE id = x2b($1)
`

type GetPersonByIDRow struct {
	ID        string    `db:"id" json:"id"`
	Name      string    `db:"name" json:"name"`
	CreatedAt time.Time `db:"created_at" json:"created_at"`
	UpdatedAt time.Time `db:"updated_at" json:"updated_at"`
}

func (q *Queries) GetPersonByID(ctx context.Context, id string) (GetPersonByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getPersonByID, id)
	var i GetPersonByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPersonByName = `-- name: GetPersonByName :one
SELECT b2x(id) as id, name, created_at, updated_at
FROM person
WHERE name = $1
`

type GetPersonByNameRow struct {
	ID        string    `db:"id" json:"id"`
	Name      string    `db:"name" json:"name"`
	CreatedAt time.Time `db:"created_at" json:"created_at"`
	UpdatedAt time.Time `db:"updated_at" json:"updated_at"`
}

func (q *Queries) GetPersonByName(ctx context.Context, name string) (GetPersonByNameRow, error) {
	row := q.db.QueryRowContext(ctx, getPersonByName, name)
	var i GetPersonByNameRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listPersons = `-- name: ListPersons :many
SELECT b2x(id) as id, name, created_at, updated_at
FROM person
ORDER BY created_at DESC
LIMIT $2 OFFSET $1
`

type ListPersonsParams struct {
	Offset int32 `db:"offset" json:"offset"`
	Limit  int32 `db:"limit" json:"limit"`
}

type ListPersonsRow struct {
	ID        string    `db:"id" json:"id"`
	Name      string    `db:"name" json:"name"`
	CreatedAt time.Time `db:"created_at" json:"created_at"`
	UpdatedAt time.Time `db:"updated_at" json:"updated_at"`
}

func (q *Queries) ListPersons(ctx context.Context, arg ListPersonsParams) ([]ListPersonsRow, error) {
	rows, err := q.db.QueryContext(ctx, listPersons, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPersonsRow{}
	for rows.Next() {
		var i ListPersonsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPersonsWithLastAction = `-- name: ListPersonsWithLastAction :many
SELECT
    b2x(p.id) as id,
    p.name,
    p.created_at,
    p.updated_at,
    MAX(a.occurred_at) as last_action_at
FROM person p
LEFT JOIN action a ON p.id = a.person_id
GROUP BY p.id, p.name, p.created_at, p.updated_at
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $1
`

type ListPersonsWithLastActionParams struct {
	Offset int32 `db:"offset" json:"offset"`
	Limit  int32 `db:"limit" json:"limit"`
}

type ListPersonsWithLastActionRow struct {
	ID           string      `db:"id" json:"id"`
	Name         string      `db:"name" json:"name"`
	CreatedAt    time.Time   `db:"created_at" json:"created_at"`
	UpdatedAt    time.Time   `db:"updated_at" json:"updated_at"`
	LastActionAt interface{} `db:"last_action_at" json:"last_action_at"`
}

func (q *Queries) ListPersonsWithLastAction(ctx context.Context, arg ListPersonsWithLastActionParams) ([]ListPersonsWithLastActionRow, error) {
	rows, err := q.db.QueryContext(ctx, listPersonsWithLastAction, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPersonsWithLastActionRow{}
	for rows.Next() {
		var i ListPersonsWithLastActionRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastActionAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPersonsByName = `-- name: SearchPersonsByName :many
SELECT b2x(id) as id, name, created_at, updated_at
FROM person
WHERE name ILIKE '%' || $1 || '%'
ORDER BY name
LIMIT $3 OFFSET $2
`

type SearchPersonsByNameParams struct {
	Search sql.NullString `db:"search" json:"search"`
	Offset int32          `db:"offset" json:"offset"`
	Limit  int32          `db:"limit" json:"limit"`
}

type SearchPersonsByNameRow struct {
	ID        string    `db:"id" json:"id"`
	Name      string    `db:"name" json:"name"`
	CreatedAt time.Time `db:"created_at" json:"created_at"`
	UpdatedAt time.Time `db:"updated_at" json:"updated_at"`
}

func (q *Queries) SearchPersonsByName(ctx context.Context, arg SearchPersonsByNameParams) ([]SearchPersonsByNameRow, error) {
	rows, err := q.db.QueryContext(ctx, searchPersonsByName, arg.Search, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchPersonsByNameRow{}
	for rows.Next() {
		var i SearchPersonsByNameRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePerson = `-- name: UpdatePerson :one
UPDATE person
SET name = $1, updated_at = NOW()
WHERE id = x2b($2)
RETURNING b2x(id) as id, name, created_at, updated_at
`

type UpdatePersonParams struct {
	Name string `db:"name" json:"name"`
	ID   string `db:"id" json:"id"`
}

type UpdatePersonRow struct {
	ID        string    `db:"id" json:"id"`
	Name      string    `db:"name" json:"name"`
	CreatedAt time.Time `db:"created_at" json:"created_at"`
	UpdatedAt time.Time `db:"updated_at" json:"updated_at"`
}

func (q *Queries) UpdatePerson(ctx context.Context, arg UpdatePersonParams) (UpdatePersonRow, error) {
	row := q.db.QueryRowContext(ctx, updatePerson, arg.Name, arg.ID)
	var i UpdatePersonRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
