// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: conversations.sql

package db

import (
	"context"
	"time"
)

const countConversationsByPersonID = `-- name: CountConversationsByPersonID :one
SELECT COUNT(DISTINCT c.id)
FROM conversation c
JOIN action_conversation ac ON ac.conversation_id = c.id
JOIN action a ON a.id = ac.action_id
WHERE a.person_id = x2b($1)
`

func (q *Queries) CountConversationsByPersonID(ctx context.Context, personID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countConversationsByPersonID, personID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createConversation = `-- name: CreateConversation :one
INSERT INTO conversation (id, person_id, description, occurred_at)
VALUES (
    x2b($1),
    x2b($2),
    $3,
    $4
)
RETURNING conversation.id, conversation.person_id, conversation.description, conversation.occurred_at, conversation.created_at, conversation.updated_at
`

type CreateConversationParams struct {
	ID          string    `db:"id" json:"id"`
	PersonID    string    `db:"person_id" json:"person_id"`
	Description string    `db:"description" json:"description"`
	OccurredAt  time.Time `db:"occurred_at" json:"occurred_at"`
}

type CreateConversationRow struct {
	Conversation Conversation `db:"conversation" json:"conversation"`
}

func (q *Queries) CreateConversation(ctx context.Context, arg CreateConversationParams) (CreateConversationRow, error) {
	row := q.db.QueryRowContext(ctx, createConversation,
		arg.ID,
		arg.PersonID,
		arg.Description,
		arg.OccurredAt,
	)
	var i CreateConversationRow
	err := row.Scan(
		&i.Conversation.ID,
		&i.Conversation.PersonID,
		&i.Conversation.Description,
		&i.Conversation.OccurredAt,
		&i.Conversation.CreatedAt,
		&i.Conversation.UpdatedAt,
	)
	return i, err
}

const listConversationsByPersonID = `-- name: ListConversationsByPersonID :many
SELECT DISTINCT ON (c.id)
    c.id, c.description, c.occurred_at, c.created_at, c.updated_at
FROM conversation c
JOIN action_conversation ac ON ac.conversation_id = c.id
JOIN action a ON a.id = ac.action_id
WHERE a.person_id = x2b($1)
ORDER BY c.id, c.occurred_at DESC
LIMIT $3 OFFSET $2
`

type ListConversationsByPersonIDParams struct {
	PersonID string `db:"person_id" json:"person_id"`
	Offset   int32  `db:"offset" json:"offset"`
	Limit    int32  `db:"limit" json:"limit"`
}

type ListConversationsByPersonIDRow struct {
	Conversation Conversation `db:"conversation" json:"conversation"`
}

func (q *Queries) ListConversationsByPersonID(ctx context.Context, arg ListConversationsByPersonIDParams) ([]ListConversationsByPersonIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listConversationsByPersonID, arg.PersonID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListConversationsByPersonIDRow{}
	for rows.Next() {
		var i ListConversationsByPersonIDRow
		if err := rows.Scan(
			&i.Conversation.ID,
			&i.Conversation.Description,
			&i.Conversation.OccurredAt,
			&i.Conversation.CreatedAt,
			&i.Conversation.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
