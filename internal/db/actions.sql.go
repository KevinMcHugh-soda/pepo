// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: actions.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const countActions = `-- name: CountActions :one
SELECT COUNT(*) FROM action
`

func (q *Queries) CountActions(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countActionsByPersonID = `-- name: CountActionsByPersonID :one
SELECT COUNT(*) FROM action WHERE person_id = x2b($1)
`

func (q *Queries) CountActionsByPersonID(ctx context.Context, personID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActionsByPersonID, personID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAction = `-- name: CreateAction :one
INSERT INTO action (id, person_id, occurred_at, description, "references", valence)
VALUES (
    x2b($1),
    x2b($2),
    $3,
    $4,
    $5,
    $6
)
RETURNING action.id, action.person_id, action.occurred_at, action.description, action."references", action.valence, action.created_at, action.updated_at
`

type CreateActionParams struct {
	ID          string         `db:"id" json:"id"`
	PersonID    string         `db:"person_id" json:"person_id"`
	OccurredAt  time.Time      `db:"occurred_at" json:"occurred_at"`
	Description string         `db:"description" json:"description"`
	References  sql.NullString `db:"references" json:"references"`
	Valence     ValenceType    `db:"valence" json:"valence"`
}

type CreateActionRow struct {
	Action Action `db:"action" json:"action"`
}

func (q *Queries) CreateAction(ctx context.Context, arg CreateActionParams) (CreateActionRow, error) {
	row := q.db.QueryRowContext(ctx, createAction,
		arg.ID,
		arg.PersonID,
		arg.OccurredAt,
		arg.Description,
		arg.References,
		arg.Valence,
	)
	var i CreateActionRow
	err := row.Scan(
		&i.Action.ID,
		&i.Action.PersonID,
		&i.Action.OccurredAt,
		&i.Action.Description,
		&i.Action.References,
		&i.Action.Valence,
		&i.Action.CreatedAt,
		&i.Action.UpdatedAt,
	)
	return i, err
}

const deleteAction = `-- name: DeleteAction :exec
DELETE FROM action
WHERE id = x2b($1)
`

func (q *Queries) DeleteAction(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteAction, id)
	return err
}

const getActionByID = `-- name: GetActionByID :one
SELECT action.id, action.person_id, action.occurred_at, action.description, action."references", action.valence, action.created_at, action.updated_at
FROM action
WHERE id = x2b($1)
`

type GetActionByIDRow struct {
	Action Action `db:"action" json:"action"`
}

func (q *Queries) GetActionByID(ctx context.Context, id string) (GetActionByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getActionByID, id)
	var i GetActionByIDRow
	err := row.Scan(
		&i.Action.ID,
		&i.Action.PersonID,
		&i.Action.OccurredAt,
		&i.Action.Description,
		&i.Action.References,
		&i.Action.Valence,
		&i.Action.CreatedAt,
		&i.Action.UpdatedAt,
	)
	return i, err
}

const getActionsByDateRange = `-- name: GetActionsByDateRange :many
SELECT action.id, action.person_id, action.occurred_at, action.description, action."references", action.valence, action.created_at, action.updated_at
FROM action
WHERE occurred_at >= $1 AND occurred_at <= $2
ORDER BY occurred_at DESC
LIMIT $4 OFFSET $3
`

type GetActionsByDateRangeParams struct {
	StartTime time.Time `db:"start_time" json:"start_time"`
	EndTime   time.Time `db:"end_time" json:"end_time"`
	Offset    int32     `db:"offset" json:"offset"`
	Limit     int32     `db:"limit" json:"limit"`
}

type GetActionsByDateRangeRow struct {
	Action Action `db:"action" json:"action"`
}

func (q *Queries) GetActionsByDateRange(ctx context.Context, arg GetActionsByDateRangeParams) ([]GetActionsByDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getActionsByDateRange,
		arg.StartTime,
		arg.EndTime,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActionsByDateRangeRow{}
	for rows.Next() {
		var i GetActionsByDateRangeRow
		if err := rows.Scan(
			&i.Action.ID,
			&i.Action.PersonID,
			&i.Action.OccurredAt,
			&i.Action.Description,
			&i.Action.References,
			&i.Action.Valence,
			&i.Action.CreatedAt,
			&i.Action.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActionsWithPersonDetails = `-- name: GetActionsWithPersonDetails :many
SELECT
    b2x(a.id) as action_id,
    b2x(a.person_id) as person_id,
    p.name as person_name,
    a.occurred_at,
    a.description,
    a."references",
    a.valence,
    a.created_at,
    a.updated_at
FROM action a
JOIN person p ON a.person_id = p.id
ORDER BY a.occurred_at DESC
LIMIT $2 OFFSET $1
`

type GetActionsWithPersonDetailsParams struct {
	Offset int32 `db:"offset" json:"offset"`
	Limit  int32 `db:"limit" json:"limit"`
}

type GetActionsWithPersonDetailsRow struct {
	ActionID    string         `db:"action_id" json:"action_id"`
	PersonID    string         `db:"person_id" json:"person_id"`
	PersonName  string         `db:"person_name" json:"person_name"`
	OccurredAt  time.Time      `db:"occurred_at" json:"occurred_at"`
	Description string         `db:"description" json:"description"`
	References  sql.NullString `db:"references" json:"references"`
	Valence     ValenceType    `db:"valence" json:"valence"`
	CreatedAt   time.Time      `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time      `db:"updated_at" json:"updated_at"`
}

func (q *Queries) GetActionsWithPersonDetails(ctx context.Context, arg GetActionsWithPersonDetailsParams) ([]GetActionsWithPersonDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, getActionsWithPersonDetails, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActionsWithPersonDetailsRow{}
	for rows.Next() {
		var i GetActionsWithPersonDetailsRow
		if err := rows.Scan(
			&i.ActionID,
			&i.PersonID,
			&i.PersonName,
			&i.OccurredAt,
			&i.Description,
			&i.References,
			&i.Valence,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentActionsByPersonID = `-- name: GetRecentActionsByPersonID :many
SELECT action.id, action.person_id, action.occurred_at, action.description, action."references", action.valence, action.created_at, action.updated_at
FROM action
WHERE person_id = x2b($1) AND occurred_at >= $2
ORDER BY occurred_at DESC
LIMIT $4 OFFSET $3
`

type GetRecentActionsByPersonIDParams struct {
	PersonID string    `db:"person_id" json:"person_id"`
	Since    time.Time `db:"since" json:"since"`
	Offset   int32     `db:"offset" json:"offset"`
	Limit    int32     `db:"limit" json:"limit"`
}

type GetRecentActionsByPersonIDRow struct {
	Action Action `db:"action" json:"action"`
}

func (q *Queries) GetRecentActionsByPersonID(ctx context.Context, arg GetRecentActionsByPersonIDParams) ([]GetRecentActionsByPersonIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getRecentActionsByPersonID,
		arg.PersonID,
		arg.Since,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentActionsByPersonIDRow{}
	for rows.Next() {
		var i GetRecentActionsByPersonIDRow
		if err := rows.Scan(
			&i.Action.ID,
			&i.Action.PersonID,
			&i.Action.OccurredAt,
			&i.Action.Description,
			&i.Action.References,
			&i.Action.Valence,
			&i.Action.CreatedAt,
			&i.Action.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActions = `-- name: ListActions :many
SELECT action.id, action.person_id, action.occurred_at, action.description, action."references", action.valence, action.created_at, action.updated_at, person.name as person_name
FROM action
JOIN person ON action.person_id = person.id
ORDER BY occurred_at DESC
LIMIT $2 OFFSET $1
`

type ListActionsParams struct {
	Offset int32 `db:"offset" json:"offset"`
	Limit  int32 `db:"limit" json:"limit"`
}

type ListActionsRow struct {
	Action     Action `db:"action" json:"action"`
	PersonName string `db:"person_name" json:"person_name"`
}

func (q *Queries) ListActions(ctx context.Context, arg ListActionsParams) ([]ListActionsRow, error) {
	rows, err := q.db.QueryContext(ctx, listActions, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActionsRow{}
	for rows.Next() {
		var i ListActionsRow
		if err := rows.Scan(
			&i.Action.ID,
			&i.Action.PersonID,
			&i.Action.OccurredAt,
			&i.Action.Description,
			&i.Action.References,
			&i.Action.Valence,
			&i.Action.CreatedAt,
			&i.Action.UpdatedAt,
			&i.PersonName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActionsByPersonID = `-- name: ListActionsByPersonID :many
SELECT action.id, action.person_id, action.occurred_at, action.description, action."references", action.valence, action.created_at, action.updated_at
FROM action
WHERE person_id = x2b($1)
ORDER BY occurred_at DESC
LIMIT $3 OFFSET $2
`

type ListActionsByPersonIDParams struct {
	PersonID string `db:"person_id" json:"person_id"`
	Offset   int32  `db:"offset" json:"offset"`
	Limit    int32  `db:"limit" json:"limit"`
}

type ListActionsByPersonIDRow struct {
	Action Action `db:"action" json:"action"`
}

func (q *Queries) ListActionsByPersonID(ctx context.Context, arg ListActionsByPersonIDParams) ([]ListActionsByPersonIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listActionsByPersonID, arg.PersonID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActionsByPersonIDRow{}
	for rows.Next() {
		var i ListActionsByPersonIDRow
		if err := rows.Scan(
			&i.Action.ID,
			&i.Action.PersonID,
			&i.Action.OccurredAt,
			&i.Action.Description,
			&i.Action.References,
			&i.Action.Valence,
			&i.Action.CreatedAt,
			&i.Action.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActionsByPersonIDAndValence = `-- name: ListActionsByPersonIDAndValence :many
SELECT action.id, action.person_id, action.occurred_at, action.description, action."references", action.valence, action.created_at, action.updated_at
FROM action
WHERE person_id = x2b($1) AND valence = $2
ORDER BY occurred_at DESC
LIMIT $4 OFFSET $3
`

type ListActionsByPersonIDAndValenceParams struct {
	PersonID string      `db:"person_id" json:"person_id"`
	Valence  ValenceType `db:"valence" json:"valence"`
	Offset   int32       `db:"offset" json:"offset"`
	Limit    int32       `db:"limit" json:"limit"`
}

type ListActionsByPersonIDAndValenceRow struct {
	Action Action `db:"action" json:"action"`
}

func (q *Queries) ListActionsByPersonIDAndValence(ctx context.Context, arg ListActionsByPersonIDAndValenceParams) ([]ListActionsByPersonIDAndValenceRow, error) {
	rows, err := q.db.QueryContext(ctx, listActionsByPersonIDAndValence,
		arg.PersonID,
		arg.Valence,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActionsByPersonIDAndValenceRow{}
	for rows.Next() {
		var i ListActionsByPersonIDAndValenceRow
		if err := rows.Scan(
			&i.Action.ID,
			&i.Action.PersonID,
			&i.Action.OccurredAt,
			&i.Action.Description,
			&i.Action.References,
			&i.Action.Valence,
			&i.Action.CreatedAt,
			&i.Action.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActionsByValence = `-- name: ListActionsByValence :many
SELECT action.id, action.person_id, action.occurred_at, action.description, action."references", action.valence, action.created_at, action.updated_at
FROM action
WHERE valence = $1
ORDER BY occurred_at DESC
LIMIT $3 OFFSET $2
`

type ListActionsByValenceParams struct {
	Valence ValenceType `db:"valence" json:"valence"`
	Offset  int32       `db:"offset" json:"offset"`
	Limit   int32       `db:"limit" json:"limit"`
}

type ListActionsByValenceRow struct {
	Action Action `db:"action" json:"action"`
}

func (q *Queries) ListActionsByValence(ctx context.Context, arg ListActionsByValenceParams) ([]ListActionsByValenceRow, error) {
	rows, err := q.db.QueryContext(ctx, listActionsByValence, arg.Valence, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActionsByValenceRow{}
	for rows.Next() {
		var i ListActionsByValenceRow
		if err := rows.Scan(
			&i.Action.ID,
			&i.Action.PersonID,
			&i.Action.OccurredAt,
			&i.Action.Description,
			&i.Action.References,
			&i.Action.Valence,
			&i.Action.CreatedAt,
			&i.Action.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchActionsByDescription = `-- name: SearchActionsByDescription :many
SELECT action.id, action.person_id, action.occurred_at, action.description, action."references", action.valence, action.created_at, action.updated_at
FROM action
WHERE description ILIKE '%' || $1 || '%'
ORDER BY occurred_at DESC
LIMIT $3 OFFSET $2
`

type SearchActionsByDescriptionParams struct {
	Search sql.NullString `db:"search" json:"search"`
	Offset int32          `db:"offset" json:"offset"`
	Limit  int32          `db:"limit" json:"limit"`
}

type SearchActionsByDescriptionRow struct {
	Action Action `db:"action" json:"action"`
}

func (q *Queries) SearchActionsByDescription(ctx context.Context, arg SearchActionsByDescriptionParams) ([]SearchActionsByDescriptionRow, error) {
	rows, err := q.db.QueryContext(ctx, searchActionsByDescription, arg.Search, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchActionsByDescriptionRow{}
	for rows.Next() {
		var i SearchActionsByDescriptionRow
		if err := rows.Scan(
			&i.Action.ID,
			&i.Action.PersonID,
			&i.Action.OccurredAt,
			&i.Action.Description,
			&i.Action.References,
			&i.Action.Valence,
			&i.Action.CreatedAt,
			&i.Action.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAction = `-- name: UpdateAction :one
UPDATE action
SET person_id = x2b($1),
    occurred_at = $2,
    description = $3,
    "references" = $4,
    valence = $5,
    updated_at = NOW()
WHERE id = x2b($6)
RETURNING action.id, action.person_id, action.occurred_at, action.description, action."references", action.valence, action.created_at, action.updated_at
`

type UpdateActionParams struct {
	PersonID    string         `db:"person_id" json:"person_id"`
	OccurredAt  time.Time      `db:"occurred_at" json:"occurred_at"`
	Description string         `db:"description" json:"description"`
	References  sql.NullString `db:"references" json:"references"`
	Valence     ValenceType    `db:"valence" json:"valence"`
	ID          string         `db:"id" json:"id"`
}

type UpdateActionRow struct {
	Action Action `db:"action" json:"action"`
}

func (q *Queries) UpdateAction(ctx context.Context, arg UpdateActionParams) (UpdateActionRow, error) {
	row := q.db.QueryRowContext(ctx, updateAction,
		arg.PersonID,
		arg.OccurredAt,
		arg.Description,
		arg.References,
		arg.Valence,
		arg.ID,
	)
	var i UpdateActionRow
	err := row.Scan(
		&i.Action.ID,
		&i.Action.PersonID,
		&i.Action.OccurredAt,
		&i.Action.Description,
		&i.Action.References,
		&i.Action.Valence,
		&i.Action.CreatedAt,
		&i.Action.UpdatedAt,
	)
	return i, err
}
