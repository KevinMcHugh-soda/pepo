// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: actions.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const countActions = `-- name: CountActions :one
SELECT COUNT(*) FROM action
`

func (q *Queries) CountActions(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countActionsByPersonID = `-- name: CountActionsByPersonID :one
SELECT COUNT(*) FROM action WHERE person_id = x2b($1)
`

func (q *Queries) CountActionsByPersonID(ctx context.Context, xidStr string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActionsByPersonID, xidStr)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAction = `-- name: CreateAction :one
INSERT INTO action (id, person_id, occurred_at, description, "references", valence)
VALUES (x2b($1), x2b($2), $3, $4, $5, $6)
RETURNING action.id, action.person_id, action.occurred_at, action.description, action."references", action.valence, action.created_at, action.updated_at
`

type CreateActionParams struct {
	XidStr      string         `db:"xid_str" json:"xid_str"`
	XidStr_2    string         `db:"xid_str_2" json:"xid_str_2"`
	OccurredAt  time.Time      `db:"occurred_at" json:"occurred_at"`
	Description string         `db:"description" json:"description"`
	References  sql.NullString `db:"references" json:"references"`
	Valence     ValenceType    `db:"valence" json:"valence"`
}

type CreateActionRow struct {
	Action Action `db:"action" json:"action"`
}

func (q *Queries) CreateAction(ctx context.Context, arg CreateActionParams) (CreateActionRow, error) {
	row := q.db.QueryRowContext(ctx, createAction,
		arg.XidStr,
		arg.XidStr_2,
		arg.OccurredAt,
		arg.Description,
		arg.References,
		arg.Valence,
	)
	var i CreateActionRow
	err := row.Scan(
		&i.Action.ID,
		&i.Action.PersonID,
		&i.Action.OccurredAt,
		&i.Action.Description,
		&i.Action.References,
		&i.Action.Valence,
		&i.Action.CreatedAt,
		&i.Action.UpdatedAt,
	)
	return i, err
}

const deleteAction = `-- name: DeleteAction :exec
DELETE FROM action
WHERE id = x2b($1)
`

func (q *Queries) DeleteAction(ctx context.Context, xidStr string) error {
	_, err := q.db.ExecContext(ctx, deleteAction, xidStr)
	return err
}

const getActionByID = `-- name: GetActionByID :one
SELECT 
FROM action a
WHERE id = x2b($1)
`

type GetActionByIDRow struct {
	Action Action `db:"action" json:"action"`
}

func (q *Queries) GetActionByID(ctx context.Context, xidStr string) (GetActionByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getActionByID, xidStr)
	var i GetActionByIDRow
	err := row.Scan(
		&i.Action.ID,
		&i.Action.PersonID,
		&i.Action.OccurredAt,
		&i.Action.Description,
		&i.Action.References,
		&i.Action.Valence,
		&i.Action.CreatedAt,
		&i.Action.UpdatedAt,
	)
	return i, err
}

const getActionsByDateRange = `-- name: GetActionsByDateRange :many
SELECT action.id, action.person_id, action.occurred_at, action.description, action."references", action.valence, action.created_at, action.updated_at
FROM action
WHERE occurred_at >= $1 AND occurred_at <= $2
ORDER BY occurred_at DESC
LIMIT $3 OFFSET $4
`

type GetActionsByDateRangeParams struct {
	OccurredAt   time.Time `db:"occurred_at" json:"occurred_at"`
	OccurredAt_2 time.Time `db:"occurred_at_2" json:"occurred_at_2"`
	Limit        int32     `db:"limit" json:"limit"`
	Offset       int32     `db:"offset" json:"offset"`
}

type GetActionsByDateRangeRow struct {
	Action Action `db:"action" json:"action"`
}

func (q *Queries) GetActionsByDateRange(ctx context.Context, arg GetActionsByDateRangeParams) ([]GetActionsByDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getActionsByDateRange,
		arg.OccurredAt,
		arg.OccurredAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActionsByDateRangeRow{}
	for rows.Next() {
		var i GetActionsByDateRangeRow
		if err := rows.Scan(
			&i.Action.ID,
			&i.Action.PersonID,
			&i.Action.OccurredAt,
			&i.Action.Description,
			&i.Action.References,
			&i.Action.Valence,
			&i.Action.CreatedAt,
			&i.Action.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActionsWithPersonDetails = `-- name: GetActionsWithPersonDetails :many
SELECT
    b2x(a.id) as action_id,
    b2x(a.person_id) as person_id,
    p.name as person_name,
    a.occurred_at,
    a.description,
    a."references",
    a.valence,
    a.created_at,
    a.updated_at
FROM action a
JOIN person p ON a.person_id = p.id
ORDER BY a.occurred_at DESC
LIMIT $1 OFFSET $2
`

type GetActionsWithPersonDetailsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type GetActionsWithPersonDetailsRow struct {
	ActionID    string         `db:"action_id" json:"action_id"`
	PersonID    string         `db:"person_id" json:"person_id"`
	PersonName  string         `db:"person_name" json:"person_name"`
	OccurredAt  time.Time      `db:"occurred_at" json:"occurred_at"`
	Description string         `db:"description" json:"description"`
	References  sql.NullString `db:"references" json:"references"`
	Valence     ValenceType    `db:"valence" json:"valence"`
	CreatedAt   time.Time      `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time      `db:"updated_at" json:"updated_at"`
}

func (q *Queries) GetActionsWithPersonDetails(ctx context.Context, arg GetActionsWithPersonDetailsParams) ([]GetActionsWithPersonDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, getActionsWithPersonDetails, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActionsWithPersonDetailsRow{}
	for rows.Next() {
		var i GetActionsWithPersonDetailsRow
		if err := rows.Scan(
			&i.ActionID,
			&i.PersonID,
			&i.PersonName,
			&i.OccurredAt,
			&i.Description,
			&i.References,
			&i.Valence,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentActionsByPersonID = `-- name: GetRecentActionsByPersonID :many
SELECT action.id, action.person_id, action.occurred_at, action.description, action."references", action.valence, action.created_at, action.updated_at
FROM action
WHERE person_id = x2b($1) AND occurred_at >= $2
ORDER BY occurred_at DESC
LIMIT $3 OFFSET $4
`

type GetRecentActionsByPersonIDParams struct {
	XidStr     string    `db:"xid_str" json:"xid_str"`
	OccurredAt time.Time `db:"occurred_at" json:"occurred_at"`
	Limit      int32     `db:"limit" json:"limit"`
	Offset     int32     `db:"offset" json:"offset"`
}

type GetRecentActionsByPersonIDRow struct {
	Action Action `db:"action" json:"action"`
}

func (q *Queries) GetRecentActionsByPersonID(ctx context.Context, arg GetRecentActionsByPersonIDParams) ([]GetRecentActionsByPersonIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getRecentActionsByPersonID,
		arg.XidStr,
		arg.OccurredAt,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentActionsByPersonIDRow{}
	for rows.Next() {
		var i GetRecentActionsByPersonIDRow
		if err := rows.Scan(
			&i.Action.ID,
			&i.Action.PersonID,
			&i.Action.OccurredAt,
			&i.Action.Description,
			&i.Action.References,
			&i.Action.Valence,
			&i.Action.CreatedAt,
			&i.Action.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActions = `-- name: ListActions :many
SELECT action.id, action.person_id, action.occurred_at, action.description, action."references", action.valence, action.created_at, action.updated_at
FROM action
ORDER BY occurred_at DESC
LIMIT $1 OFFSET $2
`

type ListActionsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type ListActionsRow struct {
	Action Action `db:"action" json:"action"`
}

func (q *Queries) ListActions(ctx context.Context, arg ListActionsParams) ([]ListActionsRow, error) {
	rows, err := q.db.QueryContext(ctx, listActions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActionsRow{}
	for rows.Next() {
		var i ListActionsRow
		if err := rows.Scan(
			&i.Action.ID,
			&i.Action.PersonID,
			&i.Action.OccurredAt,
			&i.Action.Description,
			&i.Action.References,
			&i.Action.Valence,
			&i.Action.CreatedAt,
			&i.Action.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActionsByPersonID = `-- name: ListActionsByPersonID :many
SELECT action.id, action.person_id, action.occurred_at, action.description, action."references", action.valence, action.created_at, action.updated_at
FROM action
WHERE person_id = x2b($1)
ORDER BY occurred_at DESC
LIMIT $2 OFFSET $3
`

type ListActionsByPersonIDParams struct {
	XidStr string `db:"xid_str" json:"xid_str"`
	Limit  int32  `db:"limit" json:"limit"`
	Offset int32  `db:"offset" json:"offset"`
}

type ListActionsByPersonIDRow struct {
	Action Action `db:"action" json:"action"`
}

func (q *Queries) ListActionsByPersonID(ctx context.Context, arg ListActionsByPersonIDParams) ([]ListActionsByPersonIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listActionsByPersonID, arg.XidStr, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActionsByPersonIDRow{}
	for rows.Next() {
		var i ListActionsByPersonIDRow
		if err := rows.Scan(
			&i.Action.ID,
			&i.Action.PersonID,
			&i.Action.OccurredAt,
			&i.Action.Description,
			&i.Action.References,
			&i.Action.Valence,
			&i.Action.CreatedAt,
			&i.Action.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActionsByPersonIDAndValence = `-- name: ListActionsByPersonIDAndValence :many
SELECT action.id, action.person_id, action.occurred_at, action.description, action."references", action.valence, action.created_at, action.updated_at
FROM action
WHERE person_id = x2b($1) AND valence = $2
ORDER BY occurred_at DESC
LIMIT $3 OFFSET $4
`

type ListActionsByPersonIDAndValenceParams struct {
	XidStr  string      `db:"xid_str" json:"xid_str"`
	Valence ValenceType `db:"valence" json:"valence"`
	Limit   int32       `db:"limit" json:"limit"`
	Offset  int32       `db:"offset" json:"offset"`
}

type ListActionsByPersonIDAndValenceRow struct {
	Action Action `db:"action" json:"action"`
}

func (q *Queries) ListActionsByPersonIDAndValence(ctx context.Context, arg ListActionsByPersonIDAndValenceParams) ([]ListActionsByPersonIDAndValenceRow, error) {
	rows, err := q.db.QueryContext(ctx, listActionsByPersonIDAndValence,
		arg.XidStr,
		arg.Valence,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActionsByPersonIDAndValenceRow{}
	for rows.Next() {
		var i ListActionsByPersonIDAndValenceRow
		if err := rows.Scan(
			&i.Action.ID,
			&i.Action.PersonID,
			&i.Action.OccurredAt,
			&i.Action.Description,
			&i.Action.References,
			&i.Action.Valence,
			&i.Action.CreatedAt,
			&i.Action.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActionsByValence = `-- name: ListActionsByValence :many
SELECT action.id, action.person_id, action.occurred_at, action.description, action."references", action.valence, action.created_at, action.updated_at
FROM action
WHERE valence = $1
ORDER BY occurred_at DESC
LIMIT $2 OFFSET $3
`

type ListActionsByValenceParams struct {
	Valence ValenceType `db:"valence" json:"valence"`
	Limit   int32       `db:"limit" json:"limit"`
	Offset  int32       `db:"offset" json:"offset"`
}

type ListActionsByValenceRow struct {
	Action Action `db:"action" json:"action"`
}

func (q *Queries) ListActionsByValence(ctx context.Context, arg ListActionsByValenceParams) ([]ListActionsByValenceRow, error) {
	rows, err := q.db.QueryContext(ctx, listActionsByValence, arg.Valence, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActionsByValenceRow{}
	for rows.Next() {
		var i ListActionsByValenceRow
		if err := rows.Scan(
			&i.Action.ID,
			&i.Action.PersonID,
			&i.Action.OccurredAt,
			&i.Action.Description,
			&i.Action.References,
			&i.Action.Valence,
			&i.Action.CreatedAt,
			&i.Action.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchActionsByDescription = `-- name: SearchActionsByDescription :many
SELECT action.id, action.person_id, action.occurred_at, action.description, action."references", action.valence, action.created_at, action.updated_at
FROM action
WHERE description ILIKE '%' || $1 || '%'
ORDER BY occurred_at DESC
LIMIT $2 OFFSET $3
`

type SearchActionsByDescriptionParams struct {
	Column1 sql.NullString `db:"column_1" json:"column_1"`
	Limit   int32          `db:"limit" json:"limit"`
	Offset  int32          `db:"offset" json:"offset"`
}

type SearchActionsByDescriptionRow struct {
	Action Action `db:"action" json:"action"`
}

func (q *Queries) SearchActionsByDescription(ctx context.Context, arg SearchActionsByDescriptionParams) ([]SearchActionsByDescriptionRow, error) {
	rows, err := q.db.QueryContext(ctx, searchActionsByDescription, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchActionsByDescriptionRow{}
	for rows.Next() {
		var i SearchActionsByDescriptionRow
		if err := rows.Scan(
			&i.Action.ID,
			&i.Action.PersonID,
			&i.Action.OccurredAt,
			&i.Action.Description,
			&i.Action.References,
			&i.Action.Valence,
			&i.Action.CreatedAt,
			&i.Action.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAction = `-- name: UpdateAction :one
UPDATE action
SET person_id = x2b($2), occurred_at = $3, description = $4, "references" = $5, valence = $6, updated_at = NOW()
WHERE id = x2b($1)
RETURNING action.id, action.person_id, action.occurred_at, action.description, action."references", action.valence, action.created_at, action.updated_at
`

type UpdateActionParams struct {
	XidStr      string         `db:"xid_str" json:"xid_str"`
	XidStr_2    string         `db:"xid_str_2" json:"xid_str_2"`
	OccurredAt  time.Time      `db:"occurred_at" json:"occurred_at"`
	Description string         `db:"description" json:"description"`
	References  sql.NullString `db:"references" json:"references"`
	Valence     ValenceType    `db:"valence" json:"valence"`
}

type UpdateActionRow struct {
	Action Action `db:"action" json:"action"`
}

func (q *Queries) UpdateAction(ctx context.Context, arg UpdateActionParams) (UpdateActionRow, error) {
	row := q.db.QueryRowContext(ctx, updateAction,
		arg.XidStr,
		arg.XidStr_2,
		arg.OccurredAt,
		arg.Description,
		arg.References,
		arg.Valence,
	)
	var i UpdateActionRow
	err := row.Scan(
		&i.Action.ID,
		&i.Action.PersonID,
		&i.Action.OccurredAt,
		&i.Action.Description,
		&i.Action.References,
		&i.Action.Valence,
		&i.Action.CreatedAt,
		&i.Action.UpdatedAt,
	)
	return i, err
}
